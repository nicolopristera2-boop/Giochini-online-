<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rogue Pixel - Final Fix</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * { box-sizing: border-box; }

        body { 
            font-family: 'Press Start 2P', cursive; 
            margin: 0; padding: 0;
            background-color: #111; color: #fff; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; overflow: hidden; 
            user-select: none; touch-action: none; overscroll-behavior-y: none; 
        }

        .game-container {
            position: relative; width: 800px; height: 600px;
            background-color: #000; border: 4px solid #444; border-radius: 4px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8); overflow: hidden;
            display: flex; flex-direction: column;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        .ui-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); color: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 50;
        }
        .hidden { display: none !important; }

        h2 { color: #e74c3c; margin-bottom: 30px; text-shadow: 4px 4px #000; font-size: 1.5rem; text-align: center; line-height: 2rem;}
        
        .char-grid { display: flex; gap: 40px; margin-bottom: 30px; }
        .char-btn { font-size: 3rem; background: #222; border: 4px solid #fff; padding: 20px; cursor: pointer; transition: 0.2s; }
        .char-btn:hover { transform: scale(1.1); border-color: #e74c3c; color: #e74c3c; }

        input { font-family: 'Press Start 2P'; padding: 15px; font-size: 1rem; background: #222; color: #fff; border: 2px solid #fff; text-align: center; margin-bottom: 20px; outline: none; }
        .btn-start { font-family: 'Press Start 2P'; padding: 15px 30px; background: #e74c3c; color: #fff; border: 4px solid #fff; cursor: pointer; border-radius: 4px; }

        /* HUD */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 15px;
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-text { font-size: 16px; text-shadow: 2px 2px 0 #000; color: white; }
        .key-icon { font-size: 24px; display: none; text-shadow: 0 0 10px gold; }

        /* Dialog Box */
        #dialogBox {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; min-height: 80px; 
            background: rgba(0, 0, 0, 0.9); border: 4px solid #fff; border-radius: 8px;
            padding: 20px; font-size: 14px; line-height: 22px; text-align: left;
            display: none; z-index: 40; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #mobileControls { display: none; }
        .back-btn { pointer-events: auto; text-decoration: none; color: #aaa; font-size: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; }

        @media (max-width: 850px) {
            body { background-color: #c0c0c0; justify-content: flex-start; }
            .game-container { width: 100%; height: 100dvh; border: none; border-radius: 0; background-color: #c0c0c0; }
            .screen-bezel {
                background-color: #555; border-radius: 10px 10px 40px 10px; margin: 5px 10px 0 10px; 
                flex: 1; display: flex; justify-content: center; align-items: center; padding: 0; position: relative;
                box-shadow: inset 2px 2px 5px rgba(0,0,0,0.6); overflow: hidden;
            }
            canvas { background-color: #111; width: 100%; height: 100%; object-fit: contain; }
            #mobileControls {
                display: flex; width: 100%; height: auto; min-height: 220px;
                justify-content: space-between; align-items: center;
                padding: 10px 20px; padding-bottom: calc(20px + env(safe-area-inset-bottom));
                background: #c0c0c0; flex-shrink: 0; 
            }
            .d-pad { position: relative; width: 130px; height: 130px; }
            .d-btn { position: absolute; background: #222; border: none; width: 42px; height: 42px; box-shadow: 0 4px 0 #000; border-radius: 4px; }
            .d-btn:active { transform: translate(0, 4px); box-shadow: none; background: #444; }
            #btnUp { top: 0; left: 44px; } #btnDown { bottom: 0; left: 44px; }
            #btnLeft { top: 44px; left: 0; } #btnRight { top: 44px; right: 0; }
            .d-center { position: absolute; top: 44px; left: 44px; width: 42px; height: 42px; background: #222; }
            .action-area { transform: rotate(-15deg); display: flex; gap: 20px; margin-bottom: 20px; }
            .a-btn { width: 60px; height: 60px; border-radius: 50%; background: #8f1c3f; border: none; box-shadow: 2px 4px 0 #4a0f25; color: rgba(255,255,255,0.2); font-weight: bold; font-size: 1.2rem; }
            .a-btn:active { transform: translate(2px, 4px); box-shadow: none; }
            .brand { position: absolute; bottom: calc(10px + env(safe-area-inset-bottom)); right: 20px; font-family: sans-serif; font-style: italic; color: #666; font-weight: bold; font-size: 12px; opacity: 0.6; letter-spacing: 1px;}
            #dialogBox { width: 95%; bottom: 10px; font-size: 12px; padding: 15px; }
        }
    </style>
</head>
<body>

<div class="game-container">
    <div class="screen-bezel">
        <div id="hud-layer">
            <div class="hud-text" id="level-text">LVL 1</div>
            <div class="key-icon" id="key-icon">ðŸ”‘</div>
            <a href="index.html" class="back-btn">EXIT</a>
        </div>

        <div id="screenSelection" class="ui-screen">
            <h2>ROGUE PIXEL<br>DUNGEON</h2>
            <div class="char-grid">
                <div class="char-btn" onclick="selectChar('ðŸ‘¦')">ðŸ‘¦</div>
                <div class="char-btn" onclick="selectChar('ðŸ‘§')">ðŸ‘§</div>
            </div>
            <p style="color:#aaa; font-size:0.7rem; margin-top:20px;">Livelli infiniti â€¢ Generazione Procedurale</p>
        </div>
        
        <div id="screenName" class="ui-screen hidden">
            <h2>CHI SEI?</h2>
            <input type="text" id="playerNameInput" placeholder="EREO" maxlength="8">
            <button class="btn-start" onclick="startGame()">ENTRA</button>
        </div>

        <div id="dialogBox"></div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="mobileControls">
        <div class="d-pad">
            <div class="d-center"></div>
            <button id="btnUp" class="d-btn"></button>
            <button id="btnDown" class="d-btn"></button>
            <button id="btnLeft" class="d-btn"></button>
            <button id="btnRight" class="d-btn"></button>
        </div>
        <div class="brand">NINTENDO GAME BOY</div>
        <div class="action-area">
            <button class="a-btn">B</button>
            <button id="btnAction" class="a-btn">A</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const dialogBox = document.getElementById('dialogBox');
    const levelText = document.getElementById('level-text');
    const keyIcon = document.getElementById('key-icon');

    let isPlaying = false;
    let dialogTimer = null;
    let gameTime = 0;
    
    let player = { x: 100, y: 300, w: 28, h: 28, speed: 6, sprite: "ðŸ‘¦", name: "Link", facing: 1 };
    const keys = {};

    let state = {
        level: 1,
        hasKey: false,
        hasBoots: false,
        hasFlashlight: false,
        hasGoggles: false
    };

    let currentRoom = { name: "", bgType: "", objects: [], darkness: false };

    // --- GENERATORE DI LIVELLI (CORRETTO) ---
    
    function generateLevel(level) {
        state.hasKey = false;
        keyIcon.style.display = "none";
        levelText.innerText = "LVL " + level;

        const themes = ["wood", "stone", "tile", "tech", "wood_old"];
        let themeIndex = Math.min(Math.floor(Math.random() * (2 + level * 0.5)), themes.length - 1);
        let theme = themes[themeIndex];
        if(level % 5 === 0) theme = "tech"; 

        currentRoom = {
            name: "PIANO " + level + " - " + theme.toUpperCase(),
            bgType: theme,
            objects: [],
            darkness: (level > 6 && Math.random() > 0.5)
        };

        // --- MURI PERIMETRALI (FIX USCITA) ---
        addObj(0, 0, 800, 50, "wall"); // Top
        addObj(0, 550, 800, 50, "wall"); // Bottom
        addObj(0, 0, 50, 600, "wall"); // Left
        
        // Muro Destro SPEZZATO per l'uscita
        addObj(750, 0, 50, 250, "wall"); // Parte sopra
        addObj(750, 350, 50, 250, "wall"); // Parte sotto
        
        // La Porta (nel buco)
        addObj(750, 250, 50, 100, "door", { req: "hasKey" });

        // Player start
        player.x = 100; player.y = 300; 

        // Generazione Ostacoli
        let numObstacles = 3 + level * 2;
        if (numObstacles > 20) numObstacles = 20;

        for(let i=0; i<numObstacles; i++) {
            let type = "crate";
            let rand = Math.random();
            
            if(theme === "wood" || theme === "wood_old") {
                if(rand > 0.7) type = "table";
                else if(rand > 0.5) type = "wall_hedge"; 
                else type = "shelf";
            } else if (theme === "tech") {
                if(rand > 0.6) type = "serverRack";
                else if(rand > 0.4) type = "gen";
                else type = "pipe";
            } else {
                if(rand > 0.7) type = "rock"; 
                else type = "wall";
            }

            if (level >= 4 && Math.random() > 0.85) type = "acid"; 
            if (level >= 8 && Math.random() > 0.9) type = "laser";

            let rx = 100 + Math.floor(Math.random() * 11) * 50; 
            let ry = 100 + Math.floor(Math.random() * 8) * 50;
            
            // Verifica sovrapposizione con porta/spawn
            if (Math.abs(rx - 750) < 100 && Math.abs(ry - 250) < 100) continue; // Zona uscita
            if (Math.abs(rx - 100) < 100 && Math.abs(ry - 300) < 100) continue; // Zona spawn

            let rw = 50; let rh = 50;
            if(type === "wall" || type === "shelf" || type === "acid" || type === "rock") { 
                if(Math.random()>0.5) rw = 100; else rh = 100; 
            }
            addObj(rx, ry, rw, rh, type);
        }

        // Chiave
        let keyPlaced = false;
        while(!keyPlaced) {
            let kx = 200 + Math.random() * 400;
            let ky = 100 + Math.random() * 400;
            let safe = true;
            for(let o of currentRoom.objects) { if(checkRect(kx, ky, 40, 40, o)) safe = false; }
            if(safe) {
                let loot = (level % 3 === 0) ? "goldChest" : "chest";
                addObj(kx, ky, 50, 40, loot, { contains: "key" });
                keyPlaced = true;
            }
        }

        // Aiuti
        if(level === 3 && !state.hasBoots) spawnItem("boots");
        if(level === 5 && !state.hasFlashlight) spawnItem("flashlight");
    }

    function spawnItem(itemType) {
        let ix = 300 + Math.random() * 200;
        let iy = 200 + Math.random() * 200;
        addObj(ix, iy, 40, 40, itemType, { pickup: true });
    }

    function addObj(x, y, w, h, type, props = {}) {
        let obj = { x, y, w, h, type, solid: true, ...props };
        if(["rug", "flower", "acid", "laser", "cobweb", "pipe"].includes(type) || props.pickup) obj.solid = false;
        currentRoom.objects.push(obj);
    }

    // --- LOGICA ---
    function checkRect(x, y, w, h, obj) {
        return (x < obj.x + obj.w && x + w > obj.x && y < obj.y + obj.h && y + h > obj.y);
    }

    function checkCollision(nx, ny) {
        if (nx < 0 || nx > 800 - player.w || ny < 0 || ny > 600 - player.h) return true;
        for (let obj of currentRoom.objects) {
            if (obj.pickedUp) continue; 
            if (obj.solid) {
                if (nx < obj.x + obj.w && nx + player.w > obj.x &&
                    ny < obj.y + obj.h && ny + player.h > obj.y) {
                    return true;
                }
            }
        }
        return false;
    }

    function interact() {
        let cx = player.x + player.w/2; let cy = player.y + player.h/2;
        for (let obj of currentRoom.objects) {
            if (obj.pickedUp) continue;
            let ox = obj.x + obj.w/2; let oy = obj.y + obj.h/2;
            if (Math.hypot(cx - ox, cy - oy) < 80) { handleInteraction(obj); return; }
        }
    }

    function handleInteraction(obj) {
        if(obj.pickup) {
            obj.pickedUp = true;
            if(obj.type === "flashlight") state.hasFlashlight = true;
            if(obj.type === "boots") state.hasBoots = true;
            showDialog("Hai preso: " + obj.type.toUpperCase());
            return;
        }
        if(obj.type.includes("chest")) {
            if(obj.opened) { showDialog("GiÃ  aperto."); return; }
            obj.opened = true;
            if(obj.contains === "key") {
                state.hasKey = true;
                keyIcon.style.display = "block";
                showDialog("Hai trovato la CHIAVE!");
            } else { showDialog("Vuoto."); }
            return;
        }
        if(obj.type === "door") {
            if(state.hasKey) {
                showDialog("Livello Completato!");
                state.level++;
                setTimeout(() => generateLevel(state.level), 1000);
            } else { showDialog("Chiusa. Trova la chiave."); }
        }
        if(obj.type === "gen") showDialog("Bzzzt...");
        if(obj.type === "shelf") showDialog("Libri vecchi.");
    }

    function checkHazards() {
        let px = player.x + player.w/2; let py = player.y + player.h/2;
        for (let obj of currentRoom.objects) {
            if (obj.pickedUp) continue;
            if (obj.type === "acid" && !state.hasBoots) {
                if (px > obj.x && px < obj.x + obj.w && py > obj.y && py < obj.y + obj.h) {
                    player.x = 100; player.y = 300; showDialog("L'acido brucia!");
                }
            }
        }
    }

    function showDialog(text) {
        dialogBox.innerText = text; dialogBox.style.display='block';
        if(dialogTimer) clearTimeout(dialogTimer);
        dialogTimer = setTimeout(()=>dialogBox.style.display='none', 3000);
    }

    // --- RENDERER (FIX QUADRATI GRIGI) ---
    function draw() {
        gameTime++;
        drawFloor(currentRoom.bgType);

        // Disegna PRIMA le cose piatte (pavimento, tappeti, macchie)
        currentRoom.objects.forEach(obj => {
            if(["rug", "dirt", "acid", "flower", "cobweb"].includes(obj.type)) drawObject(obj);
        });

        // Sort Y per oggetti 3D
        let renderList = currentRoom.objects.filter(obj => !["rug", "dirt", "acid", "flower", "cobweb"].includes(obj.type));
        renderList.push({ ...player, isPlayer: true });
        renderList.sort((a,b) => (a.y + a.h) - (b.y + b.h));

        renderList.forEach(obj => {
            if (obj.pickedUp) return;
            if (obj.isPlayer) drawPlayer();
            else drawObject(obj); 
        });

        // Buio
        if (currentRoom.darkness && !state.hasFlashlight) {
            ctx.fillStyle = "rgba(0,0,0,0.96)"; ctx.fillRect(0,0,800,600);
            let grad = ctx.createRadialGradient(player.x+14, player.y+14, 20, player.x+14, player.y+14, 130);
            grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,1)");
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(player.x+14, player.y+14, 130, 0, Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }

        ctx.fillStyle = "#fff"; ctx.font = "20px 'Press Start 2P'"; ctx.textAlign = "left"; 
        ctx.fillText(currentRoom.name, 20, 40);
    }

    function drawFloor(type) {
        let sz = 40;
        let c1="#5d4037", c2="#4e342e";
        if (type === "stone") { c1="#424242"; c2="#616161"; sz=50; }
        if (type === "tile") { c1="#ecf0f1"; c2="#bdc3c7"; sz=50; }
        if (type === "tech") { c1="#263238"; c2="#37474f"; sz=50; }
        
        for(let y=0; y<600; y+=sz) for(let x=0; x<800; x+=sz) {
            ctx.fillStyle = ((x+y)%(sz*2)===0) ? c1 : c2; ctx.fillRect(x, y, sz, sz);
            if(type==="wood" || type==="wood_old") { ctx.fillStyle="rgba(0,0,0,0.1)"; ctx.fillRect(x,y,sz,2); }
        }
    }

    function drawObject(obj) {
        ctx.save();

        // 1. OGGETTI 2.5D (Muri, Rocce)
        if (obj.type === "wall" || obj.type === "wall_hedge" || obj.type === "rock") {
            let isHedge = obj.type === "wall_hedge";
            let isRock = obj.type === "rock";
            let face = isHedge ? "#1b5e20" : (isRock ? "#546e7a" : "#616161"); 
            let top = isHedge ? "#2e7d32" : (isRock ? "#78909c" : "#757575");
            
            ctx.fillStyle = face; ctx.fillRect(obj.x, obj.y, obj.w, obj.h); // Fronte
            ctx.fillStyle = top; ctx.fillRect(obj.x, obj.y, obj.w, 15); // Sopra
            ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            
            if(isRock) { // Dettagli roccia
                ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.fillRect(obj.x+10, obj.y+20, 10, 10);
            }
            ctx.restore(); return;
        }

        // Ombra Base
        if(!["acid", "rug", "flower", "cobweb"].includes(obj.type)) {
            ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(obj.x + obj.w/2, obj.y + obj.h - 2, obj.w/2, 6, 0, 0, Math.PI*2); ctx.fill();
        }

        // 2. ARREDAMENTO & INTERATTIVI
        if (obj.type.includes("chest")) {
            let col = obj.opened ? "#5d4037" : (obj.type==="goldChest"?"#f1c40f":"#8d6e63");
            ctx.fillStyle = col; ctx.fillRect(obj.x, obj.y+10, obj.w, obj.h-10); 
            if(!obj.opened) {
                ctx.fillStyle = col; ctx.filter="brightness(1.2)"; ctx.fillRect(obj.x, obj.y, obj.w, 15); // Coperchio
                ctx.fillStyle = "#000"; ctx.fillRect(obj.x+obj.w/2-3, obj.y+10, 6, 8); 
            } else {
                ctx.fillStyle = "#000"; ctx.fillRect(obj.x+5, obj.y+5, obj.w-10, 10); 
            }
            ctx.filter="none"; ctx.strokeStyle="#000"; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
        }
        else if(obj.type === "door") {
            ctx.fillStyle = state.hasKey ? "#27ae60" : "#c0392b"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeStyle="#fff"; ctx.lineWidth=3; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            ctx.fillStyle="#fff"; ctx.font="10px Arial"; ctx.fillText(state.hasKey ? "OPEN" : "LOCK", obj.x+5, obj.y+obj.h/2);
        }
        else if (obj.type === "crate") {
            ctx.fillStyle = "#8d6e63"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeStyle = "#5d4037"; ctx.lineWidth=2; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            ctx.beginPath(); ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x+obj.w, obj.y+obj.h); ctx.stroke();
        }
        else if (obj.type === "table") {
            ctx.fillStyle = "#5d4037"; ctx.fillRect(obj.x+5, obj.y+10, 10, obj.h-10); ctx.fillRect(obj.x+obj.w-15, obj.y+10, 10, obj.h-10);
            ctx.fillStyle = "#ecf0f1"; ctx.fillRect(obj.x, obj.y, obj.w, 20); 
        }
        else if (obj.type === "shelf") {
            ctx.fillStyle = "#5d4037"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            for(let i=15; i<obj.h; i+=25) {
                ctx.fillStyle = "#3e2723"; ctx.fillRect(obj.x, obj.y+i, obj.w, 4);
                for(let k=5; k<obj.w-10; k+=10) { ctx.fillStyle = `hsl(${(k*20)%360}, 60%, 50%)`; ctx.fillRect(obj.x+k, obj.y+i-15, 6, 15); }
            }
        }
        else if (obj.type === "gen") {
            ctx.fillStyle = "#34495e"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.fillStyle = "#f1c40f"; ctx.fillRect(obj.x+10, obj.y+20, 10, obj.h-40);
        }
        else if (obj.type === "serverRack") {
            ctx.fillStyle = "#2d3436"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.fillStyle = "#00b894"; for(let i=10; i<obj.h; i+=15) if(Math.random()>0.5) ctx.fillRect(obj.x+5, obj.y+i, 4, 4);
        }
        else if (obj.type === "pipe") {
            ctx.fillStyle = "#95a5a6"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        }
        else if (obj.type === "acid") {
            ctx.fillStyle = "rgba(46, 204, 113, 0.8)"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            if(gameTime%20<10) { ctx.fillStyle="#fff"; ctx.fillRect(obj.x+Math.random()*obj.w, obj.y+Math.random()*obj.h, 4, 4); }
        }
        else if (obj.pickup) {
            ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(obj.x+obj.w/2, obj.y+obj.h/2, 10, 0, Math.PI*2); ctx.fill();
            if(obj.type==="boots") ctx.fillStyle="orange"; 
            if(obj.type==="flashlight") ctx.fillStyle="white";
            ctx.fill();
        }
        else {
            // Fallback (per non vedere grigio se dimentico qualcosa)
            ctx.fillStyle = "#795548"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        }
        ctx.restore();
    }

    function drawPlayer() {
        ctx.font = "32px serif"; ctx.textAlign = "center"; ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.beginPath(); ctx.ellipse(player.x+14, player.y+26, 10, 4, 0, 0, Math.PI*2); ctx.fill();
        let breathe = Math.sin(gameTime * 0.1) * 2;
        if (player.facing === -1) { ctx.translate(player.x+28, player.y + breathe); ctx.scale(-1, 1); ctx.fillText(player.sprite, 14, 28); } 
        else { ctx.fillText(player.sprite, player.x+14, player.y+28 + breathe); }
        ctx.restore();
    }

    window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code==='Space' && isPlaying) interact(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    function bindTouch(id, code) {
        const btn = document.getElementById(id); if(!btn) return;
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[code] = true; if(code==='Space' && isPlaying) interact(); }, {passive: false});
        btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[code] = false; }, {passive: false});
        btn.addEventListener('mousedown', (e) => { keys[code] = true; if(code==='Space' && isPlaying) interact(); });
        btn.addEventListener('mouseup', (e) => { keys[code] = false; });
    }
    bindTouch('btnUp', 'ArrowUp'); bindTouch('btnDown', 'ArrowDown'); bindTouch('btnLeft', 'ArrowLeft'); bindTouch('btnRight', 'ArrowRight'); bindTouch('btnAction', 'Space');

    function update() {
        if (!isPlaying) return;
        gameTime++;
        let nx = player.x, ny = player.y;
        if (keys.ArrowUp) ny -= player.speed; if (keys.ArrowDown) ny += player.speed;
        if (keys.ArrowLeft) { nx -= player.speed; player.facing = -1; } if (keys.ArrowRight) { nx += player.speed; player.facing = 1; }
        if (!checkCollision(nx, player.y)) player.x = nx;
        if (!checkCollision(player.x, ny)) player.y = ny;
        checkHazards();
    }
    function loop() { update(); draw(); requestAnimationFrame(loop); }
    function selectChar(s) { player.sprite = s; document.getElementById('screenSelection').classList.add('hidden'); document.getElementById('screenName').classList.remove('hidden'); }
    function startGame() { 
        player.name = document.getElementById('playerNameInput').value || "Eroe"; 
        document.getElementById('screenName').classList.add('hidden'); 
        isPlaying = true; 
        generateLevel(1); 
        loop(); 
    }
</script>
</body>
</html>
